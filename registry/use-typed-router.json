{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-typed-router",
  "type": "registry:hook",
  "title": "Use Typed Router",
  "files": [
    {
      "type": "registry:hook",
      "path": "registry/default/use-typed-router.tsx",
      "content": "import { useRouter as useNextRouter } from \"next/navigation\";\nimport type { ParamMap } from \"@/.next/types/routes\";\n\n// Derive route types from Next.js generated ParamMap\ntype Href = keyof ParamMap;\ntype HrefsWithoutParams = {\n  [K in Href]: ParamMap[K] extends Record<string, never> ? K : never;\n}[Href];\ntype HrefsWithParams = Exclude<Href, HrefsWithoutParams>;\n\n// Navigation options subset we support (mirrors next/navigation types we need)\ntype NavOptions = {\n  readonly scroll?: boolean;\n};\n\n// Precompiled regex for performance & lint compliance\nconst dynamicSegmentRegex = /\\[(\\.\\.\\.)?([A-Za-z0-9_]+)\\]/g;\nconst unresolvedBracketsRegex = /\\[|\\]/;\n\nfunction buildDynamicHref(\n  pattern: string,\n  params: Record<string, unknown> | undefined,\n): string {\n  if (!params || Object.keys(params).length === 0) {\n    return pattern;\n  }\n  const missing: string[] = [];\n  const result = pattern.replace(\n    dynamicSegmentRegex,\n    (match, dots: string | undefined, name: string) => {\n      const value = params[name];\n      if (dots) {\n        if (!Array.isArray(value)) {\n          throw new Error(\n            `Expected catch-all param \"${name}\" to be string[] for route ${pattern}`,\n          );\n        }\n        if (value.length === 0) {\n          missing.push(name);\n          return match;\n        }\n        return value.map((v) => encodeURIComponent(String(v))).join(\"/\");\n      }\n      if (value == null || Array.isArray(value)) {\n        missing.push(name);\n        return match;\n      }\n      return encodeURIComponent(String(value));\n    },\n  );\n  if (missing.length > 0) {\n    throw new Error(\n      `Missing required route param(s): ${missing.join(\", \")} for pattern ${pattern}`,\n    );\n  }\n  if (unresolvedBracketsRegex.test(result)) {\n    throw new Error(\n      `Unresolved dynamic segment(s) remain in built href: ${result}`,\n    );\n  }\n  return result;\n}\n\n// Overload sets for push / replace / prefetch\ntype PushWithParamsFn = {\n  <H extends HrefsWithParams>(\n    href: H,\n    options: NavOptions & { readonly params: ParamMap[H] },\n  ): void;\n  (href: HrefsWithoutParams, options?: NavOptions): void;\n};\n\ntype ReplaceWithParamsFn = {\n  <H extends HrefsWithParams>(\n    href: H,\n    options: NavOptions & { readonly params: ParamMap[H] },\n  ): void;\n  (href: HrefsWithoutParams, options?: NavOptions): void;\n};\n\ntype PrefetchWithParamsFn = {\n  <H extends HrefsWithParams>(\n    href: H,\n    options: { readonly params: ParamMap[H] },\n  ): Promise<void> | void;\n  (href: HrefsWithoutParams, options?: undefined): Promise<void> | void;\n};\n\nexport type TypedRouter = {\n  push: PushWithParamsFn;\n  replace: ReplaceWithParamsFn;\n  prefetch: PrefetchWithParamsFn;\n  back(): void;\n  forward(): void;\n  refresh(): void;\n};\n\n/**\n * ### useRouter but fully typed (tanstack router inspired):\n *\n * code example\n *\n * ```tsx\n * const router = useRouter();\n * router.replace('/o/[orgSlug]', {\n *   params: { orgSlug: 'my-org' },\n *   scroll: true\n * });\n * ```\n */\nexport function useTypedRouter(): TypedRouter {\n  const r = useNextRouter();\n\n  const push: PushWithParamsFn = (\n    href: string,\n    options?: NavOptions & { params?: Record<string, unknown> },\n  ) => {\n    const built = buildDynamicHref(href, options?.params);\n    const { params: _ignore, ...nav } = options ?? {};\n    r.push(built as never, nav);\n  };\n\n  const replace: ReplaceWithParamsFn = (\n    href: string,\n    options?: NavOptions & { params?: Record<string, unknown> },\n  ) => {\n    const built = buildDynamicHref(href, options?.params);\n    const { params: _ignore, ...nav } = options ?? {};\n    r.replace(built as never, nav);\n  };\n\n  const prefetch: PrefetchWithParamsFn = (\n    href: string,\n    options?: { params?: Record<string, unknown> },\n  ) => {\n    const built = buildDynamicHref(href, options?.params);\n    return r.prefetch(built as never);\n  };\n\n  return {\n    push,\n    replace,\n    prefetch,\n    back: r.back,\n    forward: r.forward,\n    refresh: r.refresh,\n  };\n}\n"
    }
  ]
}